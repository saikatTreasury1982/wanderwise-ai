import { query, queryTx, withTransaction } from '@/app/lib/db';
import type { Transaction } from '@libsql/client';
import type { CostLineItem, ModuleBreakdown, TravelerShare, FxItem, CostForecastReport } from '@/app/lib/types/cost-forecast';
import { getExchangeRates } from './exchange-rate';

interface CostCollectorOptions {
  tripId: number;
  statuses: string[];
}

interface TravelerInfo {
  traveler_id: number;
  traveler_name: string;
  is_primary: number;
  is_cost_sharer: number;
  traveler_currency: string;
}

interface CategoryInfo {
  category_id: number;
  category_name: string;
}

/**
 * Get or create expense category by name
 */
async function getOrCreateCategory(tx: Transaction, categoryName: string): Promise<number> {
  const existing = await queryTx<CategoryInfo>(
    tx,
    `SELECT category_id FROM expense_categories WHERE category_name = ?`,
    [categoryName]
  );

  if (existing.length > 0) {
    return existing[0].category_id;
  }

  // Create category
  await queryTx(
    tx,
    `INSERT INTO expense_categories (category_name, category_description) VALUES (?, ?)`,
    [categoryName, `Auto-created category for ${categoryName}`]
  );

  const [{ id }] = await queryTx<{ id: number }>(tx, `SELECT last_insert_rowid() as id`, []);
  return id;
}

/**
 * Get cost sharers for a trip
 */
async function getCostSharers(tripId: number): Promise<TravelerInfo[]> {
  return query<TravelerInfo>(
    `SELECT traveler_id, traveler_name, is_primary, is_cost_sharer, traveler_currency
     FROM trip_travelers
     WHERE trip_id = ? AND is_cost_sharer = 1 AND is_active = 1
     ORDER BY is_primary DESC, traveler_name`,
    [tripId]
  );
}

/**
 * Get primary cost sharer's currency (base currency for the report)
 */
async function getBaseCurrency(tripId: number): Promise<string> {
  const results = await query<{ traveler_currency: string }>(
    `SELECT traveler_currency
     FROM trip_travelers
     WHERE trip_id = ? AND is_primary = 1 AND is_cost_sharer = 1
     LIMIT 1`,
    [tripId]
  );

  if (results.length > 0 && results[0].traveler_currency) {
    return results[0].traveler_currency;
  }

  // Fallback: any cost sharer's currency
  const fallback = await query<{ traveler_currency: string }>(
    `SELECT traveler_currency
     FROM trip_travelers
     WHERE trip_id = ? AND is_cost_sharer = 1 AND is_active = 1 AND traveler_currency IS NOT NULL
     LIMIT 1`,
    [tripId]
  );

  return fallback.length > 0 ? fallback[0].traveler_currency : 'USD';
}

/**
 * Delete existing auto-generated expenses for a trip and module (within transaction)
 */
async function deleteAutoGeneratedExpenses(tx: Transaction, tripId: number, sourceModule: string): Promise<void> {
  // First get expense IDs to delete splits
  const expenses = await queryTx<{ expense_id: number }>(
    tx,
    `SELECT expense_id FROM expenses WHERE trip_id = ? AND source_module = ?`,
    [tripId, sourceModule]
  );

  for (const exp of expenses) {
    await queryTx(tx, `DELETE FROM expense_splits WHERE expense_id = ?`, [exp.expense_id]);
  }

  await queryTx(
    tx,
    `DELETE FROM expenses WHERE trip_id = ? AND source_module = ?`,
    [tripId, sourceModule]
  );
}

/**
 * Validate currency exists in currencies table
 */
async function validateCurrency(tx: Transaction, currency: string): Promise<string> {
  const validCurrency = await queryTx<{ currency_code: string }>(
    tx,
    `SELECT currency_code FROM currencies WHERE currency_code = ?`,
    [currency]
  );
  return validCurrency.length > 0 ? currency : 'USD';
}

/**
 * Create expense and splits (within transaction)
 */
async function createExpenseWithSplits(
  tx: Transaction,
  tripId: number,
  categoryId: number,
  description: string,
  amount: number,
  currency: string,
  sourceModule: string,
  sourceId: number,
  costSharers: TravelerInfo[]
): Promise<number> {
  // Validate currency
  const expenseCurrency = await validateCurrency(tx, currency);

  // Create expense
  await queryTx(
    tx,
    `INSERT INTO expenses (trip_id, category_id, is_shared, split_method, expense_description, estimated_amount, expense_currency, source_module, source_id)
     VALUES (?, ?, 1, 'equal', ?, ?, ?, ?, ?)`,
    [tripId, categoryId, description, amount, expenseCurrency, sourceModule, sourceId]
  );

  const [{ id }] = await queryTx<{ id: number }>(tx, `SELECT last_insert_rowid() as id`, []);
  const expenseId = id;

  // Create equal splits for each cost sharer
  if (costSharers.length > 0) {
    const splitAmount = amount / costSharers.length;
    const splitPercentage = 100 / costSharers.length;

    for (const traveler of costSharers) {
      await queryTx(
        tx,
        `INSERT INTO expense_splits (expense_id, traveler_id, estimated_split_amount, split_percentage)
         VALUES (?, ?, ?, ?)`,
        [expenseId, traveler.traveler_id, splitAmount, splitPercentage]
      );
    }
  }

  return expenseId;
}

/**
 * Collect flight costs and save to expenses (within transaction)
 */
async function collectAndSaveFlightCosts(
  tx: Transaction,
  tripId: number,
  statuses: string[],
  categoryId: number,
  costSharers: TravelerInfo[]
): Promise<CostLineItem[]> {
  if (statuses.length === 0) return [];

  // Delete existing auto-generated flight expenses
  await deleteAutoGeneratedExpenses(tx, tripId, 'flights');

  const placeholders = statuses.map(() => '?').join(',');
  const flights = await queryTx<{
    flight_option_id: number;
    flight_type: string;
    total_price: number;
    currency_code: string;
    status: string;
    notes: string | null;
  }>(
    tx,
    `SELECT 
      flight_option_id,
      flight_type,
      total_price,
      currency_code,
      status,
      notes
     FROM flight_options
     WHERE trip_id = ? AND status IN (${placeholders}) AND total_price IS NOT NULL`,
    [tripId, ...statuses]
  );

  const items: CostLineItem[] = [];

  for (const f of flights) {
    const description = f.notes || `Flight (${f.flight_type || 'one_way'})`;

    await createExpenseWithSplits(
      tx,
      tripId,
      categoryId,
      description,
      f.total_price,
      f.currency_code || 'USD',
      'flights',
      f.flight_option_id,
      costSharers
    );

    items.push({
      id: f.flight_option_id,
      module: 'flights',
      description,
      amount: f.total_price,
      currency_code: f.currency_code || 'USD',
      cost_type: 'total',
      status: f.status,
    });
  }

  return items;
}

/**
 * Collect accommodation costs and save to expenses (within transaction)
 */
async function collectAndSaveAccommodationCosts(
  tx: Transaction,
  tripId: number,
  statuses: string[],
  categoryId: number,
  costSharers: TravelerInfo[]
): Promise<CostLineItem[]> {
  if (statuses.length === 0) return [];

  // Delete existing auto-generated accommodation expenses
  await deleteAutoGeneratedExpenses(tx, tripId, 'accommodations');

  const placeholders = statuses.map(() => '?').join(',');
  const accommodations = await queryTx<{
    accommodation_option_id: number;
    accommodation_name: string | null;
    total_price: number | null;
    price_per_night: number | null;
    check_in_date: string | null;
    check_out_date: string | null;
    currency_code: string;
    status: string;
  }>(
    tx,
    `SELECT 
      accommodation_option_id,
      accommodation_name,
      total_price,
      price_per_night,
      check_in_date,
      check_out_date,
      currency_code,
      status
     FROM accommodation_options
     WHERE trip_id = ? AND status IN (${placeholders})`,
    [tripId, ...statuses]
  );

  const items: CostLineItem[] = [];

  for (const a of accommodations) {
    let amount = 0;
    if (a.total_price) {
      amount = a.total_price;
    } else if (a.price_per_night && a.check_in_date && a.check_out_date) {
      // Calculate nights from dates
      const checkIn = new Date(a.check_in_date);
      const checkOut = new Date(a.check_out_date);
      const nights = Math.ceil((checkOut.getTime() - checkIn.getTime()) / (1000 * 60 * 60 * 24));
      if (nights > 0) {
        amount = a.price_per_night * nights;
      }
    }

    if (amount <= 0) continue;

    const description = a.accommodation_name || `Accommodation #${a.accommodation_option_id}`;

    await createExpenseWithSplits(
      tx,
      tripId,
      categoryId,
      description,
      amount,
      a.currency_code || 'USD',
      'accommodations',
      a.accommodation_option_id,
      costSharers
    );

    items.push({
      id: a.accommodation_option_id,
      module: 'accommodations',
      description,
      amount,
      currency_code: a.currency_code || 'USD',
      cost_type: 'total',
      status: a.status,
    });
  }

  return items;
}

/**
 * Collect itinerary costs and save to expenses (within transaction)
 */
async function collectAndSaveItineraryCosts(
  tx: Transaction,
  tripId: number,
  categoryId: number,
  costSharers: TravelerInfo[]
): Promise<CostLineItem[]> {
  // Delete existing auto-generated itinerary expenses
  await deleteAutoGeneratedExpenses(tx, tripId, 'itinerary');

  const items: CostLineItem[] = [];

  // Get activities with costs
  const activities = await queryTx<{
    activity_id: number;
    activity_name: string;
    activity_cost: number;
    currency_code: string;
    cost_type: string;
    headcount: number | null;
    day_number: number;
  }>(
    tx,
    `SELECT 
      ia.activity_id,
      ia.activity_name,
      ia.activity_cost,
      ia.currency_code,
      ia.cost_type,
      ia.headcount,
      id.day_number
     FROM itinerary_activities ia
     JOIN itinerary_day_categories idc ON ia.category_id = idc.category_id
     JOIN itinerary_days id ON idc.day_id = id.day_id
     WHERE id.trip_id = ? AND ia.activity_cost IS NOT NULL AND ia.currency_code IS NOT NULL`,
    [tripId]
  );

  for (const a of activities) {
    let amount = a.activity_cost;
    if (a.cost_type === 'per_head' && a.headcount) {
      amount = a.activity_cost * a.headcount;
    }

    const description = `Day ${a.day_number}: ${a.activity_name}`;

    await createExpenseWithSplits(
      tx,
      tripId,
      categoryId,
      description,
      amount,
      a.currency_code,
      'itinerary',
      a.activity_id,
      costSharers
    );

    items.push({
      id: a.activity_id,
      module: 'itinerary',
      description,
      amount,
      currency_code: a.currency_code,
      cost_type: (a.cost_type as 'total' | 'per_head') || 'total',
      headcount: a.headcount || undefined,
    });
  }

  // Get category-level costs
  const categories = await queryTx<{
    category_id: number;
    category_name: string;
    category_cost: number;
    currency_code: string;
    cost_type: string;
    headcount: number | null;
    day_number: number;
  }>(
    tx,
    `SELECT 
      idc.category_id,
      idc.category_name,
      idc.category_cost,
      idc.currency_code,
      idc.cost_type,
      idc.headcount,
      id.day_number
     FROM itinerary_day_categories idc
     JOIN itinerary_days id ON idc.day_id = id.day_id
     WHERE id.trip_id = ? AND idc.category_cost IS NOT NULL AND idc.currency_code IS NOT NULL`,
    [tripId]
  );

  for (const c of categories) {
    let amount = c.category_cost;
    if (c.cost_type === 'per_head' && c.headcount) {
      amount = c.category_cost * c.headcount;
    }

    const description = `Day ${c.day_number}: ${c.category_name} (Category)`;

    await createExpenseWithSplits(
      tx,
      tripId,
      categoryId,
      description,
      amount,
      c.currency_code,
      'itinerary',
      c.category_id + 100000, // Offset to avoid collision with activity IDs
      costSharers
    );

    items.push({
      id: c.category_id + 100000,
      module: 'itinerary',
      description,
      amount,
      currency_code: c.currency_code,
      cost_type: (c.cost_type as 'total' | 'per_head') || 'total',
      headcount: c.headcount || undefined,
    });
  }

  return items;
}

/**
 * Main cost collector function - collects and saves to database within a transaction
 */
export async function collectCosts(options: CostCollectorOptions): Promise<CostForecastReport> {
  const { tripId, statuses } = options;

  // Get base currency and cost sharers (read-only, outside transaction)
  const baseCurrency = await getBaseCurrency(tripId);
  const costSharers = await getCostSharers(tripId);

  // Collect and save within a transaction
  const { flightCosts, accommodationCosts, itineraryCosts } = await withTransaction(async (tx) => {
    // Get or create expense categories
    const flightsCategoryId = await getOrCreateCategory(tx, 'Flights');
    const accommodationsCategoryId = await getOrCreateCategory(tx, 'Accommodations');
    const itineraryCategoryId = await getOrCreateCategory(tx, 'Itinerary');

    // Collect and save costs from all modules
    const flightCosts = await collectAndSaveFlightCosts(tx, tripId, statuses, flightsCategoryId, costSharers);
    const accommodationCosts = await collectAndSaveAccommodationCosts(tx, tripId, statuses, accommodationsCategoryId, costSharers);
    const itineraryCosts = await collectAndSaveItineraryCosts(tx, tripId, itineraryCategoryId, costSharers);

    return { flightCosts, accommodationCosts, itineraryCosts };
  });

  const allItems = [...flightCosts, ...accommodationCosts, ...itineraryCosts];

  // Get all unique currencies for FX conversion
  const currencies = [...new Set(allItems.map(i => i.currency_code))];
  
  // Fetch exchange rates (outside transaction - external API call)
  const ratesResult = await getExchangeRates(baseCurrency, currencies);
  const rates = ratesResult.rates;

  // Convert all items to base currency and track FX items
  const fxItems: FxItem[] = [];
  let totalCost = 0;

  for (const item of allItems) {
    if (item.currency_code === baseCurrency) {
      item.converted_amount = item.amount;
      item.exchange_rate = 1;
      totalCost += item.amount;
    } else {
      // Need to convert TO base currency (inverse of what we fetched)
      const foreignRate = rates[item.currency_code];
      if (foreignRate) {
        const toBaseRate = 1 / foreignRate;
        item.converted_amount = item.amount * toBaseRate;
        item.exchange_rate = toBaseRate;
        totalCost += item.converted_amount;

        fxItems.push({
          module: item.module,
          description: item.description,
          original_amount: item.amount,
          original_currency: item.currency_code,
          exchange_rate: toBaseRate,
          converted_amount: item.converted_amount,
          converted_currency: baseCurrency,
        });
      } else {
        // No rate available, use original amount
        item.converted_amount = item.amount;
        totalCost += item.amount;
      }
    }
  }

  // Build module breakdown
  const moduleBreakdown: ModuleBreakdown[] = [
    {
      module: 'flights',
      total: flightCosts.reduce((sum, i) => sum + (i.converted_amount || i.amount), 0),
      currency_code: baseCurrency,
      items_count: flightCosts.length,
      items: flightCosts,
    },
    {
      module: 'accommodations',
      total: accommodationCosts.reduce((sum, i) => sum + (i.converted_amount || i.amount), 0),
      currency_code: baseCurrency,
      items_count: accommodationCosts.length,
      items: accommodationCosts,
    },
    {
      module: 'itinerary',
      total: itineraryCosts.reduce((sum, i) => sum + (i.converted_amount || i.amount), 0),
      currency_code: baseCurrency,
      items_count: itineraryCosts.length,
      items: itineraryCosts,
    },
  ];

  // Calculate traveler shares (equal split)
  const shareAmount = costSharers.length > 0 ? totalCost / costSharers.length : totalCost;
  
  const travelerShares: TravelerShare[] = costSharers.map(t => ({
    traveler_id: t.traveler_id,
    traveler_name: t.traveler_name,
    is_primary: t.is_primary,
    traveler_currency: t.traveler_currency || baseCurrency,
    share_amount: shareAmount,
    share_currency: baseCurrency,
  }));

  return {
    trip_id: tripId,
    base_currency: baseCurrency,
    total_cost: totalCost,
    module_breakdown: moduleBreakdown,
    traveler_shares: travelerShares,
    fx_items: fxItems,
    status_filter: statuses,
    cost_sharers_count: costSharers.length,
    generated_at: new Date().toISOString(),
  };
}

/**
 * Get existing cost forecast report from expenses table (read-only)
 */
export async function getCostForecastReport(tripId: number): Promise<CostForecastReport | null> {
  const baseCurrency = await getBaseCurrency(tripId);
  const costSharers = await getCostSharers(tripId);

  // Get all auto-generated expenses
  const expenses = await query<{
    expense_id: number;
    source_module: string;
    source_id: number;
    expense_description: string;
    estimated_amount: number;
    expense_currency: string;
  }>(
    `SELECT expense_id, source_module, source_id, expense_description, estimated_amount, expense_currency
     FROM expenses
     WHERE trip_id = ? AND source_module IS NOT NULL
     ORDER BY source_module, expense_id`,
    [tripId]
  );

  if (expenses.length === 0) {
    return null;
  }

  // Get all unique currencies for FX conversion
  const currencies = [...new Set(expenses.map(e => e.expense_currency))];
  
  // Fetch exchange rates
  const ratesResult = await getExchangeRates(baseCurrency, currencies);
  const rates = ratesResult.rates;

  // Process expenses into cost line items
  const flightCosts: CostLineItem[] = [];
  const accommodationCosts: CostLineItem[] = [];
  const itineraryCosts: CostLineItem[] = [];
  const fxItems: FxItem[] = [];
  let totalCost = 0;

  for (const exp of expenses) {
    const item: CostLineItem = {
      id: exp.source_id,
      module: exp.source_module as 'flights' | 'accommodations' | 'itinerary',
      description: exp.expense_description,
      amount: exp.estimated_amount,
      currency_code: exp.expense_currency,
      cost_type: 'total',
    };

    // Convert to base currency
    if (exp.expense_currency === baseCurrency) {
      item.converted_amount = exp.estimated_amount;
      item.exchange_rate = 1;
      totalCost += exp.estimated_amount;
    } else {
      const foreignRate = rates[exp.expense_currency];
      if (foreignRate) {
        const toBaseRate = 1 / foreignRate;
        item.converted_amount = exp.estimated_amount * toBaseRate;
        item.exchange_rate = toBaseRate;
        totalCost += item.converted_amount;

        fxItems.push({
          module: exp.source_module,
          description: exp.expense_description,
          original_amount: exp.estimated_amount,
          original_currency: exp.expense_currency,
          exchange_rate: toBaseRate,
          converted_amount: item.converted_amount,
          converted_currency: baseCurrency,
        });
      } else {
        item.converted_amount = exp.estimated_amount;
        totalCost += exp.estimated_amount;
      }
    }

    // Add to appropriate module
    switch (exp.source_module) {
      case 'flights':
        flightCosts.push(item);
        break;
      case 'accommodations':
        accommodationCosts.push(item);
        break;
      case 'itinerary':
        itineraryCosts.push(item);
        break;
    }
  }

  // Build module breakdown
  const moduleBreakdown: ModuleBreakdown[] = [
    {
      module: 'flights',
      total: flightCosts.reduce((sum, i) => sum + (i.converted_amount || i.amount), 0),
      currency_code: baseCurrency,
      items_count: flightCosts.length,
      items: flightCosts,
    },
    {
      module: 'accommodations',
      total: accommodationCosts.reduce((sum, i) => sum + (i.converted_amount || i.amount), 0),
      currency_code: baseCurrency,
      items_count: accommodationCosts.length,
      items: accommodationCosts,
    },
    {
      module: 'itinerary',
      total: itineraryCosts.reduce((sum, i) => sum + (i.converted_amount || i.amount), 0),
      currency_code: baseCurrency,
      items_count: itineraryCosts.length,
      items: itineraryCosts,
    },
  ];

  // Calculate traveler shares
  const shareAmount = costSharers.length > 0 ? totalCost / costSharers.length : totalCost;
  
  const travelerShares: TravelerShare[] = costSharers.map(t => ({
    traveler_id: t.traveler_id,
    traveler_name: t.traveler_name,
    is_primary: t.is_primary,
    traveler_currency: t.traveler_currency || baseCurrency,
    share_amount: shareAmount,
    share_currency: baseCurrency,
  }));

  return {
    trip_id: tripId,
    base_currency: baseCurrency,
    total_cost: totalCost,
    module_breakdown: moduleBreakdown,
    traveler_shares: travelerShares,
    fx_items: fxItems,
    status_filter: [],
    cost_sharers_count: costSharers.length,
    generated_at: new Date().toISOString(),
  };
}